\chapter{Implementation Details} \label{cap:implementation}


%---------------------------
% Counter
%---------------------------

\section{Counter Metric Implementation}

The \texttt{Counter} metric implementation adheres to the Prometheus convention of representing monotonically increasing values, typically used to count events such as HTTP requests, errors, or completed tasks.

\subsection{Construction and Registration}
The \texttt{counter} DSL function allows users to build and register counters in a declarative manner:
\begin{verbatim}
val requests = counter("http_requests_total") {
    help("Total HTTP requests")
    labelNames("method", "status")
}
\end{verbatim}
Internally, this utilizes a \texttt{CounterBuilder} which constructs and registers a \texttt{Counter} instance.




\subsection{Metric Semantics and Structure}
The \texttt{Counter} class extends a generic \texttt{SimpleCollector} and supports optional labels, units, and the inclusion of a \texttt{\_created} time series. The final metric name is normalized to include a \texttt{\_total} suffix, and optionally a unit suffix:
\begin{verbatim}
if (unit.isNotBlank()) {
    metricName = "${metricName}_${unit}"
}
return "${metricName}_total"
\end{verbatim}



%Atomic Value Handling

\subsection{Atomic Value Handling}

Due to the lack of native atomic floating-point primitives in Kotlin/Native, counter values in this implementation are managed using the \texttt{kotlinx.atomicfu} library. Each labeled instance of the counter is encapsulated within a \texttt{Child} class, where the internal value is stored as a raw bit representation of a \texttt{Double} using an atomic \texttt{Long}.

\paragraph{Why not use \texttt{AtomicRef<Double>}?}  
At first glance, it may seem sufficient to store a \texttt{Double} value using an \texttt{AtomicRef}. However, this approach introduces inefficiencies in a concurrent environment. Since Kotlin/Native lacks atomic increment operations for \texttt{Double}, using an atomic reference would require manual compare-and-set (CAS) loops to ensure thread safety, as shown below:

\begin{verbatim}
while (true) {
    val current = value.value
    val updated = current + amount
    if (value.compareAndSet(current, updated)) {
        return
    }
}
\end{verbatim}

This approach may lead to excessive CPU usage, especially under high contention, due to repeated CAS failures and retries.

\paragraph{Raw Bits Workaround}

Instead, the implementation stores the \texttt{Double} value as its raw IEEE 754 bit representation in a \texttt{Long}. This allows atomic updates using the efficient \texttt{updateAndGet} operation provided by \texttt{atomicfu}:

\begin{verbatim}
value.updateAndGet { currentBits ->
    val current = Double.fromBits(currentBits)
    val updated = current + amount
    updated.toBits()
}
\end{verbatim}

This approach ensures atomicity in a single operation, avoiding busy-wait loops and improving performance in concurrent scenarios. It also maintains correct floating-point semantics without introducing data races or synchronization issues.


\begin{verbatim}
private var value = atomic(0.0.toRawBits())
\end{verbatim}



%Other Viable Option

\paragraph{Other viable option}
Since there are multiple different uses for counters, we could optimise it for other uses.

For example:
In cases where most of the increments would be only 1
We could use two instances, one for \texttt{AtomicLong} and another one for the Double representation in rawbits \texttt{AtomicLong('Double in RawBits')} for the increments.


\begin{verbatim}
private var valueLong = atomic(0L)
private var valueDouble = atomic(0.0.toRawBits())
\end{verbatim}

And when we used inc() it would only increment the valueLong like this:
\begin{verbatim}
valueLong.incrementAndGet()
\end{verbatim}


But when used get() it would return the sum of both values:
\begin{verbatim}
return Double.fromBits(valueDouble.value) + valueLong.value
\end{verbatim}

A future enhancement could explore this dual-storage approach to a another type of Counter inside of our library.


%Concurrency Model

\subsection{Concurrency Model}
All increment operations are performed within the \texttt{Dispatchers.Default} coroutine context to ensure scalability across multiple threads. This design leverages Kotlin coroutines to provide structured concurrency and minimize blocking.

We opted out of using \texttt{Dispatchers.IO} or \texttt{Dispatchers.Unconfined} to avoid potential performance bottlenecks and ensure that counter updates are handled efficiently in a thread-safe manner.

Based on the nature of the counter it only made sense to make it available in the \texttt{Default} dispatcher, which is optimized for CPU-bound tasks. This choice aligns with the typical use cases of counters, such as counting requests or events, which are often CPU-intensive operations.

%Label Handling and Sample Collection

\subsection{Label Handling and Sample Collection}
Counters may be labeled using the \texttt{labels(...)} method. The collector stores a map from label sets to their respective \texttt{Child} instances. During metric scraping, the \texttt{collect()} method emits one sample per label set. If the \texttt{includeCreatedSeries} flag is enabled, an additional sample with the \texttt{\_created} suffix is also emitted:
\begin{verbatim}
val createdSeriesName = name.removeSuffix("_total") + "_created"
\end{verbatim}


In this implementation, the \texttt{collect()} function on the \texttt{Counter} class gathers all current values of each labeled or unlabeled counter instance and packages them as \texttt{Sample} objects. These samples are then grouped into a \texttt{MetricFamilySamples} data structure, which is Prometheus's expected format for exporting metrics.

Each call to \texttt{collect()} produces one or more samples depending on how many label sets (i.e., unique combinations of labels) have been used to increment the counter. If \texttt{includeCreatedSeries} is enabled, an additional \texttt{\_created} time series is emitted for each label set, indicating when the metric series was initialized.

\vspace{0.5em}
\noindent
\textbf{Example Sample Output}:
\begin{verbatim}
http_requests_total{method="GET", status="200"}  123.0
http_requests_created{method="GET", status="200"}  1.650e+09
\end{verbatim}

\subsection{Labeled vs Unlabeled Counter Incrementation}

Prometheus counters in this library support both labeled and unlabeled usage. The difference between these modes lies in the ability to partition metrics by key-value identifiers (labels).

\begin{itemize}
  \item \textbf{Unlabeled Counter:}
    \begin{verbatim}
    val errors = counter("error_total") { help("Total errors") }
    errors.inc()
    \end{verbatim}
    This counter tracks a single, global value without distinguishing between contexts.

  \item \textbf{Labeled Counter:}
    \begin{verbatim}
    val requests = counter("http_requests_total") {
        help("Total HTTP requests")
        labelNames("method", "status")
    }
    requests.labels("GET", "200").inc()
    \end{verbatim}
    This counter tracks separate values for each unique combination of label values.
\end{itemize}

Using labels is powerful because it enables fine-grained observability. For example, instead of one total count of HTTP requests, you can track how many were successful GETs versus failed POSTs. However, each unique label set creates a new time series, which can increase memory usage and complexity. When fine granularity is not needed, unlabeled counters offer a simpler and more efficient alternative.

%Exception Counting Utility

\subsection{Exception Counting Utility}
To facilitate observability in failure-prone operations, the implementation provides utility extensions to count exceptions:
\begin{verbatim}
counter.countExceptions(IOException::class) {
    // risky operation
}
\end{verbatim}
These suspend functions catch specified exception types and increment the counter accordingly. Both the \texttt{Counter} and its \texttt{Child} instances support this pattern.



%---------------------------
% GAUGE
%---------------------------


\section{Gauge Metric Implementation}

The \texttt{Gauge} metric implementation aligns with Prometheus semantics for representing instantaneous values that can arbitrarily go up and down. It is suitable for metrics such as current memory usage, number of active connections, or custom user-defined values.

\subsection{Construction and Registration}
The \texttt{gauge} DSL function enables declarative creation and registration of gauge metrics:
\begin{verbatim}
val temperature = gauge("room_temperature_celsius") {
    help("Current room temperature")
    labelNames("room")
}
\end{verbatim}
Internally, this uses a \texttt{GaugeBuilder} to configure and instantiate the \texttt{Gauge} metric. Label names and help descriptions are passed through the builder for validation and registration.





\subsection{Metric Semantics and Structure}
The \texttt{Gauge} class extends the generic 
\texttt{SimpleCollector} and supports optional labels, 
an optional unit, and the inclusion of a \texttt{\_created} series if desired. 
The metric name is preserved exactly as provided, with no suffix normalization (unlike counters that enforce a \texttt{\_total} suffix).

Each \texttt{Gauge} tracks a single floating-point value per label set, which may be incremented, decremented, or explicitly set. A convenience child without labels is always created if no label names are provided.


%Atomic Value Handling

\subsection{Atomic Value Handling}
Similar to the counter, the gauge uses the \texttt{kotlinx.atomicfu} library for thread-safe atomic updates of floating-point values. Each labeled instance is encapsulated in a \texttt{Child} class, which stores the internal value as a raw bitwise representation of a \texttt{Double} using an \texttt{AtomicLong}:

\begin{verbatim}
private var value = atomic(0.0.toRawBits())
\end{verbatim}

All value updates (e.g., \texttt{inc()}, \texttt{dec()}, \texttt{set()}) operate via atomic \texttt{updateAndGet()} transformations to ensure correctness and eliminate the need for locks:

\begin{verbatim}
value.updateAndGet { currentBits ->
    val current = Double.fromBits(currentBits)
    val updated = current + amount
    updated.toBits()
}
\end{verbatim}

This approach allows safe floating-point arithmetic in concurrent environments, while maintaining high performance and avoiding CAS loop pitfalls.

%Other Viable Option

\paragraph{Other viable option}
Gauges differ from counters in that they support both incrementing and decrementing, as well as setting values directly. This broader range of use cases opens the door to additional optimization strategies.

For instance, in scenarios where gauges are used primarily to reflect binary, or to increment/decrement by whole numbers in tight loops (e.g., tracking open connections), we could explore separating the fast-path operations from general-purpose floating-point updates.

A potential optimization would involve using two atomic values: one \texttt{AtomicLong} for whole number delta-based changes, and one \texttt{AtomicLong} for the base \texttt{Double} value stored in raw bits:

\begin{verbatim}
private var valueLong = atomic(0L)
private var valueDouble = atomic(0.0.toRawBits())
\end{verbatim}

In this model:

    \texttt{inc()} and \texttt{dec()} by \texttt{1.0} would operate exclusively on \texttt{valueLong}:
    \begin{verbatim}
    valueLong.incrementAndGet()
    \end{verbatim}

    \texttt{set()} would overwrite \texttt{valueDouble}, resetting the gauge’s baseline:
    \begin{verbatim}
    valueDouble.value = newValue.toRawBits()
    valueLong.value = 0L
    \end{verbatim}

    \texttt{get()} would compute the current gauge value as:
    \begin{verbatim}
    return Double.fromBits(valueDouble.value) + valueLong.value
    \end{verbatim}

This dual-storage approach would preserve general-purpose floating-point precision for arbitrary updates while optimizing for frequent whole-number changes, improving performance and reducing contention in certain workloads.

While not currently implemented, this model could serve as the basis for a specialized \texttt{IntOptimizedGauge} or \texttt{FastGauge} variant in future versions of the library, tailored to specific use cases with tighter numerical requirements.


%Concurrency Model


\subsection{Concurrency Model}
Gauge operations are suspend functions and are always executed in the \texttt{Dispatchers.Default} coroutine context. This allows for structured concurrency while ensuring that value modifications do not block the main thread:

\begin{verbatim}
withContext(Dispatchers.Default) {
    value.updateAndGet { ... }
}
\end{verbatim}

This model makes gauges suitable for high-concurrency applications such as web servers or background task schedulers.

\subsection{Tracking and Duration Utilities}
Gauges include utility functions for tracking the number of concurrent operations and measuring execution time:

\paragraph{In-Flight Task Tracking}

\begin{verbatim}
gauge.track {
    performWork()
}
\end{verbatim}

The \texttt{track()} function increments the gauge when the block begins and decrements it after the block completes, making it ideal for concurrency observability.

\paragraph{Duration Measurement}

\begin{verbatim}
gauge.setDuration {
    expensiveCall()
}
\end{verbatim}

This utility measures how long a code block takes and sets the gauge to the elapsed time in seconds. This can be used with or without labels, and supports both \texttt{Gauge} and \texttt{Gauge.Child} instances.

\subsection{Label Handling and Sample Collection}
Gauges support labels via the \texttt{labels(...)} method. A \texttt{Child} instance is maintained for each unique combination of label values. During metric collection, one sample is emitted per label set:

\begin{verbatim}
val samples = mutableListOf<Sample>()
for ((labels, child) in childMetrics) {
    samples += Sample(name, labelNames, labels, child.get())
}
\end{verbatim}

Each sample includes its respective label values and the current gauge reading. Label handling logic is inherited from \texttt{SimpleCollector}, ensuring consistency across all metric types in the library.

\subsection{What Are Samples in Gauge Metrics?}

In Prometheus, a \textit{sample} is a single point of measurement containing a metric name, optional labels, and a value. For a \texttt{Gauge}, which represents a numerical value that can increase or decrease, samples are used to report the current value at collection time.

This implementation stores one or more \texttt{Sample} instances per gauge, depending on the number of label combinations used. The \texttt{collect()} method gathers these samples by iterating through all registered \texttt{Child} instances, each tied to a distinct label set.

Unlike counters, gauges do not enforce monotonicity and can go up or down depending on the application's state (e.g., number of in-flight requests, memory usage, or temperature). Each sample accurately reflects the current value for its label set at the moment of collection.

\vspace{0.5em}
\noindent
\textbf{Example Sample Output}:
\begin{verbatim}
room_temperature_celsius{room="kitchen"} 22.5
room_temperature_celsius{room="bedroom"} 19.0
\end{verbatim}

\subsection{Labeled vs Unlabeled Gauge Incrementation}

Like counters, gauges can be used in labeled and unlabeled modes. The primary distinction lies in how they track different instances of the same metric.

\begin{itemize}
  \item \textbf{Unlabeled Gauge:}
    \begin{verbatim}
    val temperature = gauge("room_temperature_celsius") {
        help("Room temperature")
    }
    temperature.set(22.5)
    \end{verbatim}
    This gauge tracks a single, global value, without any differentiation between contexts.

  \item \textbf{Labeled Gauge:}
    \begin{verbatim}
    val temperature = gauge("room_temperature_celsius") {
        help("Room temperature")
        labelNames("room")
    }
    temperature.labels("kitchen").set(22.5)
    temperature.labels("bedroom").set(19.0)
    \end{verbatim}
    Labeled gauges maintain separate values for each unique combination of label values. This is useful when the same type of measurement must be tracked in different categories, such as rooms, users, or endpoints.
\end{itemize}

Labeled gauges provide granular observability but require careful management of label cardinality to avoid performance issues. Unlabeled gauges are simpler and more efficient when only one measurement context is needed.



\subsection{Time-Based Gauge Values}
A gauge can also be set to the current system time in Unix seconds using the \texttt{setToCurrentTime()} method. This is useful for tracking freshness or heartbeat-style metrics:

\begin{verbatim}
gauge.setToCurrentTime()
\end{verbatim}

Internally, this uses the injected \texttt{Clock} instance (defaulting to \texttt{Clock.System}) to fetch the current time and update the gauge accordingly.


%---------------------------
% HISTOGRAM
%---------------------------


%---------------------------
% SUMMARY
%---------------------------

\section{Metric Types and API Design}
\lipsum[1]


\section{Collector Registration and Logic}
\lipsum[1]


\section{Ktor Integration}
\lipsum[1]

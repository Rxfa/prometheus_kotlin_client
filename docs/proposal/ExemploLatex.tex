\documentclass[a4paper,twoside,11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{graphicx}
\usepackage{url}

% pdflatex

% redefinição das margens das páginas
\setlength{\textheight}{24.00cm}
\setlength{\textwidth}{15.50cm}
\setlength{\topmargin}{0.35cm}
\setlength{\headheight}{0cm}
\setlength{\headsep}{0cm}
\setlength{\oddsidemargin}{0.25cm}
\setlength{\evensidemargin}{0.25cm}

\title{Prometheus Kotlin Client Library}

\author{
\begin{tabular}{c}
             Mário Rijo, n.º 50561, e-mail: A50561@alunos.isel.pt, tel.: 924422578\\
             Rafael Nicolau, n.º 50546, e-mail: A50546@alunos.isel.pt, tel.: 932456007\\
\end{tabular}}

\date{
\begin{tabular}{ll}
  {Supervisor:} & José Simão, e-mail: jose.simao@isel.pt \\
\end{tabular}\\
\vspace{5mm}
March 2025}

\begin{document}

\begin{figure}
\begin{center}
\resizebox{80mm}{!}{\includegraphics{logoISEL.png}}
\end{center}
\end{figure}

\maketitle

\section{Introduction}
In this project proposal there are some key contextual topics that are important to clarify.
The following paragraphs will explain the main context in detail.

\subsection{Prometheus}
Prometheus \cite{prometheus:prometheus} is an open-source metrics-focused monitoring and alerting toolkit originally built at SoundCloud in 2012. Prometheus has, since then, become one of the most popular monitoring tools, seeing major adoption across the industry and the open-source community.
It is now a standalone open-source project maintained independently of any company, joining the Cloud Native Computing Foundation in 2016 as the second hosted project after Kubernetes.

Prometheus is a pull-based monitoring system that scrapes metrics from instrumented jobs, either directly or via an intermediary push gateway for short-lived jobs.

\subsection{Prometheus Metric Types}
Prometheus provides four key metric types for system monitoring, each designed for specific performance tracking.

\subsubsection{Counter}
A Counter only increases or resets to zero on restart, useful for tracking requests or errors.

\subsubsection{Gauge}
A Gauge can increase or decrease, monitoring fluctuating values like memory usage or active connections.

\subsubsection{Histogram}
A Histogram groups values into buckets for analyzing distributions, useful for request and latency.

\subsubsection{Summary}
A Summary provides precomputed quantiles (e.g., median, 95th percentile) for precise performance tracking.

Each type enhances observability, allowing Prometheus to monitor and diagnose system performance effectively.

\subsection{Exporting a Library}
When dealing with observability tools like Prometheus, exporting plays a crucial role in making collected metrics accessible. A library designed for observability should provide mechanisms to expose data in a structured format that monitoring systems can scrape and analyze. In the case of Prometheus, this usually means:
\begin{itemize}
    \item Providing an HTTP endpoint where metrics can be queried.
    \item Formatting data according to the Prometheus exposition format.
    \item Supporting different metric types such as counters, gauges, and histograms.
\end{itemize}

\subsection{Problem Overview}
While Prometheus provides robust monitoring capabilities, existing client libraries are primarily designed for Java and do not fully leverage Kotlin’s unique features. Many of these solutions introduce unnecessary complexity when used in Kotlin-based applications, particularly those relying on frameworks like Ktor and Http4k.  

The lack of a dedicated Prometheus library for Kotlin leads to inefficiencies, increased boilerplate code, and limited support for Kotlin's concurrency model, such as coroutines. This project aims to address these issues by providing a Kotlin-native Prometheus client that optimally integrates with Kotlin's ecosystem while maintaining performance and usability.


For a Kotlin-based Prometheus client library, the export process generally involves defining metric types, registering them within the application, and exposing them through an endpoint that Prometheus can scrape at regular intervals. This allows real-time collection and monitoring of performance data, aiding in debugging and system optimization.

\section{Problem Statement}
Existing Prometheus client libraries primarily cater to Java applications, with limited optimizations for Kotlin’s unique features. Many of these libraries require extensive boilerplate code and do not fully utilize Kotlin’s capabilities, such as coroutines for efficient asynchronous operations.

Additionally, while frameworks like Ktor and Http4k are widely used in Kotlin-based backend applications, there is no dedicated Prometheus client that seamlessly integrates with them. Developers often need to write custom wrappers or rely on Java-based solutions that may not align well with Kotlin’s idiomatic design, leading to inefficiencies and increased maintenance effort.

\section{Functional Requirements}
This project aims to address these gaps by providing a Kotlin-native Prometheus client library that:
\begin{itemize}
    \item Leverages Kotlin’s coroutines for efficient metric collection.
    \item Offers seamless integration with Kotlin frameworks such as Ktor and Http4k.
    \item Reduces boilerplate code and improves developer experience.
    \item Ensures compatibility with Prometheus while optimizing for Kotlin’s concurrency model.
    \item Provides better performance and efficiency than its Java counterpart.
\end{itemize}

\section{The Project}
The goal of this project is to develop a Prometheus client library tailored for Kotlin, leveraging Kotlin's unique features such as coroutines. This library will provide seamless integration with Kotlin-based frameworks like Ktor, Http4k, and others, enabling efficient and scalable metric collection.

Our approach focuses on extending Prometheus functionality within the Kotlin ecosystem by designing idiomatic APIs that simplify metric instrumentation while maintaining high performance. By utilizing Kotlin’s lightweight concurrency model, the library will support asynchronous metric collection, making it well-suited for modern, event-driven applications.

Additionally, the library aims to provide extensions that facilitate effortless integration with popular Kotlin-based web frameworks, ensuring developers can easily expose and monitor application metrics. We will also utilize Grafana alongside Prometheus to visualize and analyze collected metrics, enhancing the monitoring experience and providing real-time insights into system performance.

\section{Roadmap}
\begin{table}[h!]
\centering
\begin{tabular}{ |c|c|c|  }
  \hline
  Date &Duration(weeks) &Task\\
  \hline
  March 10, 2025   & 4 & \textbf{Delivery - Proposal delivery}\\
  \hline
  March 17, 2025  & 1 & Finish studying KMP and the recommended structure for the library \\
  \hline
  April 14, 2025  & 4 &Implementation of at least two of the four metric types for all supported platforms\\
  \hline
  April 28, 2025 & 2 &   \textbf{Presentation - Project progress}\\
  \hline
  May 12, 2025 & 2 &   Implemention of the two remaining metric types for all supported platforms\\
  \hline
  May 26, 2025 & 2 &   Integration with Popular Kotlin-based web frameworks\\
  \hline
  June 2, 2025 & 1 &\textbf{Delivery - Beta version}\\
  \hline
  June 23, 2025 & 3 &Testing and performance optimization\\
  \hline
  July 7, 2025 & 2 &Publication of the library on Maven Central\\
  \hline
  July 12, 2025    & 1 &\textbf{Delivery - Final version}\\
  \hline
 \end{tabular}
 \caption{Project's roadmap.}
 \label{table:2}
\end{table}

\bibliographystyle{plain}
\bibliography{refs}

\end{document}
